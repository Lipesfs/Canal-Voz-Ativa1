import os
import zipfile

# Recriar a estrutura após reset
base_path = "/mnt/data/canal-voz-ativa-backend"
os.makedirs(base_path + "/routes", exist_ok=True)
os.makedirs(base_path + "/models", exist_ok=True)
os.makedirs(base_path + "/middleware", exist_ok=True)

# Arquivos do projeto
files = {
    "server.js": """
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const messageRoutes = require('./routes/messages');
const authRoutes = require('./routes/auth');

dotenv.config();
const app = express();
app.use(cors());
app.use(express.json());

app.use('/api/mensagens', messageRoutes);
app.use('/api/auth', authRoutes);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Servidor rodando na porta ${PORT}`));
""",

    "db.js": """
const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database('./mensagens.db');

db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS mensagens (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    categoria TEXT,
    conteudo TEXT,
    data_envio DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS admins (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    usuario TEXT UNIQUE,
    senha TEXT
  )`);
});

module.exports = db;
""",

    "routes/messages.js": """
const express = require('express');
const router = express.Router();
const db = require('../db');
const authenticate = require('../middleware/authMiddleware');

router.post('/', (req, res) => {
  const { categoria, conteudo } = req.body;
  db.run('INSERT INTO mensagens (categoria, conteudo) VALUES (?, ?)', [categoria, conteudo], err => {
    if (err) return res.status(500).json({ error: 'Erro ao salvar mensagem' });
    res.json({ message: 'Mensagem enviada com sucesso' });
  });
});

router.get('/', authenticate, (req, res) => {
  db.all('SELECT * FROM mensagens ORDER BY data_envio DESC', (err, rows) => {
    if (err) return res.status(500).json({ error: 'Erro ao buscar mensagens' });
    res.json(rows);
  });
});

module.exports = router;
""",

    "routes/auth.js": """
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const db = require('../db');
const router = express.Router();

router.post('/login', (req, res) => {
  const { usuario, senha } = req.body;
  db.get('SELECT * FROM admins WHERE usuario = ?', [usuario], (err, admin) => {
    if (err || !admin) return res.status(401).json({ error: 'Usuário ou senha inválidos' });
    bcrypt.compare(senha, admin.senha, (err, same) => {
      if (!same) return res.status(401).json({ error: 'Usuário ou senha inválidos' });
      const token = jwt.sign({ id: admin.id, usuario: admin.usuario }, process.env.JWT_SECRET, { expiresIn: '2h' });
      res.json({ token });
    });
  });
});

module.exports = router;
""",

    "middleware/authMiddleware.js": """
const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(403).json({ error: 'Token não fornecido' });

  const token = authHeader.split(' ')[1];
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Token inválido' });
    req.user = user;
    next();
  });
};
""",

    ".env": "JWT_SECRET=chave_super_secreta_para_token",
    
    "package.json": """
{
  "name": "canal-voz-ativa-backend",
  "version": "1.0.0",
  "description": "Backend do Canal Voz Ativa com Node.js, Express e SQLite",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "sqlite3": "^5.1.6"
  }
}
"""
}

# Criar e salvar os arquivos
for path, content in files.items():
    full_path = os.path.join(base_path, path)
    os.makedirs(os.path.dirname(full_path), exist_ok=True)
    with open(full_path, "w", encoding="utf-8") as f:
        f.write(content.strip())

# Compactar tudo em um ZIP
zip_path = "/mnt/data/CanalVozAtiva_Backend.zip"
with zipfile.ZipFile(zip_path, "w") as zipf:
    for foldername, _, filenames in os.walk(base_path):
        for filename in filenames:
            file_path = os.path.join(foldername, filename)
            arcname = os.path.relpath(file_path, base_path)
            zipf.write(file_path, arcname)

zip_path
